(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{330:function(t,e,v){"use strict";v.r(e);var a=v(14),r=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"如何监听dom变化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何监听dom变化"}},[t._v("#")]),t._v(" 如何监听DOM变化")]),t._v(" "),e("p",[t._v("以前：")]),t._v(" "),e("ol",[e("li",[t._v("setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。\n"),e("ul",[e("li",[t._v("缺点：\n"),e("ol",[e("li",[t._v("如果时间间隔设置过长，DOM 变化响应不够及时；")]),t._v(" "),e("li",[t._v("如果时间间隔设置过短，又会浪费很多无用的工作量去检查 DOM，会让页面变得低效。")])])])])])]),t._v(" "),e("p",[t._v("现在：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("2000年引入Mutation Event，Mutation Event 采用了观察者的设计模式，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。")]),t._v(" "),e("ol",[e("li",[t._v("但是因为每次 DOM 变动，渲染引擎都会去调用 JavaScript，这样会产生较大的性能开销。")])])]),t._v(" "),e("li",[e("p",[t._v("后来改用MutationObserver")]),t._v(" "),e("ol",[e("li",[t._v("通过异步操作解决了同步操作的性能问题；")]),t._v(" "),e("li",[t._v("通过微任务解决了实时性的问题。（每次微任务队列执行完成，就到UI渲染线程）")])])])]),t._v(" "),e("h1",{attrs:{id:"mutationobserverapi和eventtargetapi的addeventlistener"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mutationobserverapi和eventtargetapi的addeventlistener"}},[t._v("#")]),t._v(" MutationObserverAPI和EventTargetAPI的addEventListener")]),t._v(" "),e("p",[t._v("共同点: 两者的回调函数执行都是异步任务，都要在主执行栈之后执行；")]),t._v(" "),e("p",[t._v("不同点：")]),t._v(" "),e("ol",[e("li",[t._v("addEventListener的回调函数会进入宏任务队列；")])]),t._v(" "),e("p",[t._v("MutationObserver的回调函数会进入微任务队列")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("addEventListener的触发方式是同步触发；比如，点击后，回调函数立即进入宏任务队列。")])]),t._v(" "),e("p",[t._v("MutationObserver的监听是异步触发，在所有的DOM操作完成后才触发使回调函数进入微任务队列。")]),t._v(" "),e("p",[t._v("比如，程序中有10个修改DOM的操作，只有在第十个处理完之后，回调函数才进入微任务队列。")]),t._v(" "),e("h1",{attrs:{id:"用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用法"}},[t._v("#")]),t._v(" 用法")]),t._v(" "),e("ul",[e("li",[t._v("待总结")])])])}),[],!1,null,null,null);e.default=r.exports}}]);
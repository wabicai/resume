(window.webpackJsonp=window.webpackJsonp||[]).push([[168],{444:function(a,_,t){"use strict";t.r(_);var v=t(14),s=Object(v.a)({},(function(){var a=this,_=a._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"_3-大文件断点续传功能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-大文件断点续传功能"}},[a._v("#")]),a._v(" 3.大文件断点续传功能")]),a._v(" "),_("h2",{attrs:{id:"各个版本的上传组件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#各个版本的上传组件"}},[a._v("#")]),a._v(" 各个版本的上传组件")]),a._v(" "),_("ol",[_("li",[a._v("原生+axios.post")]),a._v(" "),_("li",[a._v("断点续传，秒传判断，类型判断")]),a._v(" "),_("li",[a._v("web-worker，时间切片，抽样 hash")]),a._v(" "),_("li",[a._v("异步并发数控制，切片报错重试")]),a._v(" "),_("li",[a._v("慢启动，碎片清理，上传暂停")])]),a._v(" "),_("h3",{attrs:{id:"断点续传-秒传-进度条"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#断点续传-秒传-进度条"}},[a._v("#")]),a._v(" 断点续传+秒传+进度条")]),a._v(" "),_("h4",{attrs:{id:"文件切片"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#文件切片"}},[a._v("#")]),a._v(" 文件切片")]),a._v(" "),_("ul",[_("li",[a._v("文件 File 对象是 Blob 对象的子类，Blob 对象包含一个重要的方法 slice，通过这个方法，我们就可以对二进制文件进行拆分。")])]),a._v(" "),_("h4",{attrs:{id:"使用-md5-计算-hash-值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用-md5-计算-hash-值"}},[a._v("#")]),a._v(" 使用 md5 计算 hash 值")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("可以抽样 hash")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("我们将 file 解析为二进制 buffer 数据,")])]),a._v(" "),_("li",[_("p",[a._v("抽取文件头尾 2mb, 中间的部分每隔 2mb 抽取 2kb")])]),a._v(" "),_("li",[_("p",[a._v("将这些片段组合成新的 buffer,进行 md5 计算。")])])])]),a._v(" "),_("li",[_("p",[a._v("使用 worker 或者 类似 Fiber 的 requestIdleCallback 计算")])]),a._v(" "),_("li",[_("p",[a._v("使用 worker 计算文件切片 hash 值, 通过 postMessage 向主线程发送 hash 值")])])]),a._v(" "),_("h4",{attrs:{id:"秒传"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#秒传"}},[a._v("#")]),a._v(" 秒传")]),a._v(" "),_("ol",[_("li",[a._v("前端：根据后端的回应，判断文件是否已经传输过")]),a._v(" "),_("li",[a._v("后端：根据文件 hash 创建文件夹，保存文件切片，如: 文件夹 xxx 下 的文件 xxx_01, xxx_02")])]),a._v(" "),_("h4",{attrs:{id:"进度条"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进度条"}},[a._v("#")]),a._v(" 进度条")]),a._v(" "),_("ol",[_("li",[a._v("xmlHTTPRequest 回调中监听")]),a._v(" "),_("li",[a._v("手动计算上传的片段")])]),a._v(" "),_("h4",{attrs:{id:"类型判断"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类型判断"}},[a._v("#")]),a._v(" 类型判断")]),a._v(" "),_("ol",[_("li",[a._v("通过后缀判断")]),a._v(" "),_("li",[a._v("通过文件转为二进制 blob 的前几个字节判断。（有现有库）")])]),a._v(" "),_("h4",{attrs:{id:"异步并发数控制-和并发重试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异步并发数控制-和并发重试"}},[a._v("#")]),a._v(" 异步并发数控制，和并发重试")]),a._v(" "),_("ol",[_("li",[a._v("封装 100 个请求并发池")]),a._v(" "),_("li",[a._v("使用 promise.race，在 then 中递归传入下一个请求")]),a._v(" "),_("li",[a._v("使用 catch 捕获错误，给每个任务设置重试次数，超过 3 次就 reject，停止传输。")]),a._v(" "),_("li",[a._v("维护一个请求列表，存放未收到响应的请求，暂停时调用"),_("code",[a._v("xhr")]),a._v("对象的 "),_("code",[a._v("abort")]),a._v("方法。")])]),a._v(" "),_("h4",{attrs:{id:"慢启动"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#慢启动"}},[a._v("#")]),a._v(" 慢启动")]),a._v(" "),_("ol",[_("li",[a._v("参考 TCP 慢启动策略")]),a._v(" "),_("li",[a._v("设置一个初始大小，动态调整下个切片大小，确保文件切片的大小和当前网速匹配")]),a._v(" "),_("li",[a._v("时间统计、size 值")])]),a._v(" "),_("h4",{attrs:{id:"文件合并-三种方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#文件合并-三种方案"}},[a._v("#")]),a._v(" 文件合并（三种方案）")]),a._v(" "),_("ol",[_("li",[a._v("前端发送完切片，发送合并请求，后端再合并。")]),a._v(" "),_("li",[a._v("后端纪律切片数据，自动完成合并")]),a._v(" "),_("li",[a._v("创建源文件大小相同文件，根据切片起始位置直接将切片写入对应位置。")])]),a._v(" "),_("h4",{attrs:{id:"文件碎片清理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#文件碎片清理"}},[a._v("#")]),a._v(" 文件碎片清理")]),a._v(" "),_("ol",[_("li",[a._v("可能用户传到一半就不传了，可以在后端使用定时任务清理不需要的碎片文件")])])])}),[],!1,null,null,null);_.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{481:function(t,_,v){"use strict";v.r(_);var r=v(10),a=Object(r.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"_3-应用层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-应用层"}},[t._v("#")]),t._v(" 3.应用层")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzgvMTYzM2VhZDMxNmQwNzcxMw?x-oss-process=image/format,png",alt:"img"}})]),t._v(" "),_("h2",{attrs:{id:"一、dns解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、dns解析"}},[t._v("#")]),t._v(" 一、DNS解析")]),t._v(" "),_("h2",{attrs:{id:"二、http版本差异"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、http版本差异"}},[t._v("#")]),t._v(" 二、HTTP版本差异")]),t._v(" "),_("h3",{attrs:{id:"_0-9版本"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_0-9版本"}},[t._v("#")]),t._v(" 0.9版本：")]),t._v(" "),_("p",[t._v("1991年。只有GET，只支持纯文本。")]),t._v(" "),_("h3",{attrs:{id:"_1-0版本"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-0版本"}},[t._v("#")]),t._v(" 1.0版本：")]),t._v(" "),_("p",[t._v("1996年。添加POST、HEAD请求，可以传所有格式的文件。可以手动设置Connection: keep-alive，保存长链接")]),t._v(" "),_("h3",{attrs:{id:"_1-1版本"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1版本"}},[t._v("#")]),t._v(" 1.1版本")]),t._v(" "),_("p",[t._v("1997年。")]),t._v(" "),_("ul",[_("li",[t._v("默认持久连接（keep-alive）")]),t._v(" "),_("li",[t._v("管道机制（在同一个TCP连接里，客户端可以同时发送多个请求，但是会引起队头堵塞）")])]),t._v(" "),_("blockquote",[_("p",[t._v("队头堵塞：HTTP管道化要求服务端必须按"),_("strong",[t._v("照请求发送的顺序")]),t._v("返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。")])]),t._v(" "),_("ul",[_("li",[t._v("新增方法：PUT、 PATCH、 OPTIONS、 DELETE。")]),t._v(" "),_("li",[t._v("http协议不带有状态，每次请求都必须附上所有信息。请求的很多字段都是重复的，浪费带宽，影响速度。")]),t._v(" "),_("li",[t._v("http1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。")])]),t._v(" "),_("h3",{attrs:{id:"_2-0版本"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-0版本"}},[t._v("#")]),t._v(" 2.0版本")]),t._v(" "),_("p",[t._v("2015年。")]),t._v(" "),_("p",[t._v("安全高效：http2.0"),_("strong",[t._v("建立在https协议")]),t._v("的基础上，高效是因为它是通过"),_("strong",[t._v("二进制分帧")]),t._v("来进行数据传输。")]),t._v(" "),_("ul",[_("li",[t._v('**帧：**http/2是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。')]),t._v(" "),_("li",[t._v("**多路复用：**复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，从而减少了队头堵塞的问题，此双向的实时通信称为多工（ Multiplexing）。（由帧首部的流标识符进行标识。）（"),_("strong",[t._v("实际上，队头堵塞是由HTTP层和TCP层，两个方面引起的，HTTP2.0只解决了HTTP层的对头堵塞。所以HTTP2.0也存在对头堵塞的问题）")])]),t._v(" "),_("li",[_("strong",[t._v("服务器推送")]),t._v("：HTTP/2 允许服务器未经请求，主动向客户端发送资源，")]),t._v(" "),_("li",[t._v("**头部压缩：**引入头信息压缩机制（ header compression） , 头信息使用gzip或compress压缩后再发送，包括不会发送重复的字段。")])]),t._v(" "),_("h3",{attrs:{id:"_3-0版本"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-0版本"}},[t._v("#")]),t._v(" 3.0版本")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://network.51cto.com/art/202009/625999.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP3.0"),_("OutboundLink")],1)]),t._v(" "),_("p",[t._v("截至2021年6月，仍是草案阶段。")]),t._v(" "),_("p",[t._v("弃用"),_("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE",target:"_blank",rel:"noopener noreferrer"}},[t._v("TCP"),_("OutboundLink")],1),t._v("协议，改为使用基于"),_("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE",target:"_blank",rel:"noopener noreferrer"}},[t._v("UDP"),_("OutboundLink")],1),t._v("协议的"),_("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9FUDP%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5",target:"_blank",rel:"noopener noreferrer"}},[t._v("QUIC"),_("OutboundLink")],1),t._v("（Quick UDP Internet Connections）协议实现。（为了解决HTTP2.0 的队头堵塞）")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("0RTT建立连接")]),t._v("：第一个数据包就可以发送数据（也就是不需要建立链接）")]),t._v(" "),_("li",[t._v("支持"),_("strong",[t._v("连接迁移")]),t._v("：切换网络不需要重连。")]),t._v(" "),_("li",[_("strong",[t._v("无对头堵塞")])])]),t._v(" "),_("h2",{attrs:{id:"四、http的长链接和短链接的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、http的长链接和短链接的区别"}},[t._v("#")]),t._v(" 四、HTTP的长链接和短链接的区别")]),t._v(" "),_("p",[t._v("https://www.cnblogs.com/gotodsp/p/6366163.html")]),t._v(" "),_("h2",{attrs:{id:"五、多路复用和长连接的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、多路复用和长连接的区别"}},[t._v("#")]),t._v(" 五、多路复用和长连接的区别")]),t._v(" "),_("ol",[_("li",[t._v("同一个域名访问同一个文件的多个请求都可以复用一个tcp连接（不用像1.0一样 每次请求都需要重新建立连接）")]),t._v(" "),_("li",[_("strong",[t._v("依然存在的问题")]),t._v("：\n"),_("ol",[_("li",[t._v("多个请求只能被串行处理（"),_("strong",[t._v("数据基于文本，只能按顺序传输")]),t._v("）；")]),t._v(" "),_("li",[t._v("访问多个不同的文件依然会建立多个请求。")])])]),t._v(" "),_("li",[_("strong",[t._v("多路复用")]),t._v("：同一个域名访问多个文件的请求也可以复用一个tcp连接，且多个请求可以被并行处理。")]),t._v(" "),_("li",[_("strong",[t._v("并行实现原理")]),t._v("：http2.0引入二进制数据帧和流的概念（数据帧对每一个数据进行标识，可以不按顺序传输，从而实现并行）")])]),t._v(" "),_("h2",{attrs:{id:"六、https加密过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#六、https加密过程"}},[t._v("#")]),t._v(" 六、HTTPS加密过程")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("客户端主要向服务器提供以下信息，同时索要服务端的证书")]),t._v(" "),_("ol",[_("li",[t._v("支持的协议版本号")]),t._v(" "),_("li",[t._v('一个客户端生成的随机数，稍后用于生成"对话密钥"。')]),t._v(" "),_("li",[t._v("客户端支持的加密算法")]),t._v(" "),_("li",[t._v("支持的压缩算法")])])]),t._v(" "),_("li",[_("strong",[t._v("服务器回应")]),t._v(" "),_("ol",[_("li",[t._v("将自己的证书发送给客户端")]),t._v(" "),_("li",[t._v("私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。")]),t._v(" "),_("li",[t._v("证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被串改。另外，证书还有个有效期。")]),t._v(" "),_("li",[t._v("服务端也需要产生一个随机数发送给客户端。客户端和服务端都需要使用这两个随机数来产生Master Secret。")])])]),t._v(" "),_("li",[_("strong",[t._v("客户端回应")]),t._v(" "),_("ol",[_("li",[t._v("生成一个随机数，如果采用的是RSA加密方式则取出证书中的公钥，生成随机数。该随机数用服务器公钥加密，防止被窃听。")]),t._v(" "),_("li",[t._v("上面第一项的随机数，是整个握手阶段出现的第三个随机数，它是客户端使用一些加密算法")])])]),t._v(" "),_("li",[_("strong",[t._v("服务器的最后回应")])])]),t._v(" "),_("p",[t._v("1、首先，客户端 A 访问服务器 B ，比如我们用浏览器打开一个网页 "),_("a",{attrs:{href:"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.baidu.com",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.baidu.com"),_("OutboundLink")],1),t._v(" ，这时，浏览器就是客户端 A ，百度的服务器就是服务器 B 了。这时候客户端 A 会生成一个随机数1，把随机数1 、自己支持的 SSL 版本号以及加密算法等这些信息告诉服务器 B 。")]),t._v(" "),_("p",[t._v("2、服务器 B 知道这些信息后，确认一下双方的加密算法，然后服务端也生成一个随机数 B ，并将随机数 B 和 CA 颁发给自己的证书一同返回给客户端 A 。")]),t._v(" "),_("p",[t._v("3、 客户端 A 得到 CA 证书后，会去校验该 CA 证书的有效性，校验方法在上面已经说过了。校验通过后，客户端生成一个随机数3 ，然后用证书中的公钥加密随机数3 并传输给服务端 B 。服务端 B 得到加密后的随机数3，然后利用私钥进行解密，得到真正的随机数3。")]),t._v(" "),_("p",[t._v("4、最后，客户端 A 和服务端 B 都有随机数1、随机数2、随机数3，然后双方利用这三个随机数生成一个对话密钥。之后传输内容就是利用对话密钥来进行加解密了。这时就是利用了对称加密，一般用的都是 AES 算法。")]),t._v(" "),_("p",[t._v("5、 客户端 A 通知服务端 B ，指明后面的通讯用对话密钥来完成，同时通知服务器 B 客户端 A 的握手过程结束。")]),t._v(" "),_("p",[t._v("6、服务端 B 通知客户端 A，指明后面的通讯用对话密钥来完成，同时通知客户端 A 服务器 B 的握手过程结束。SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户端 A 和服务器 B 开始使用相同的对话密钥进行数据通讯。")]),t._v(" "),_("h2",{attrs:{id:"七、简单介绍加密原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#七、简单介绍加密原理"}},[t._v("#")]),t._v(" 七、简单介绍加密原理？")]),t._v(" "),_("ol",[_("li",[t._v("客户端生成随机数A，保存本地，同时发送给服务端，告诉那边我支持的加密算法，并索要证书")]),t._v(" "),_("li",[t._v("服务端生成随机数B，保存随机数A，确定加密算法，并发送证书。")]),t._v(" "),_("li",[t._v("客户端用浏览器自带的证书进行检验是否过期，合格，从证书中取出公钥，生成随机数C，对C用公钥加密。发送给服务端。")]),t._v(" "),_("li",[t._v("服务端对加密后的C用他的私钥解密，得到原来的C。")]),t._v(" "),_("li",[t._v("客户端和服务端用ABC作为下一步通信的密钥，开始对称加密通信。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);
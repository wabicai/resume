(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{372:function(r,t,e){"use strict";e.r(t);var a=e(10),s=Object(a.a)({},(function(){var r=this,t=r._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"_3-哪些方法会触发-react-重新渲染-重新渲染-render-会做些什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-哪些方法会触发-react-重新渲染-重新渲染-render-会做些什么"}},[r._v("#")]),r._v(" 3.哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？")]),r._v(" "),t("h2",{attrs:{id:"_1-哪些方法会触发-react-重新渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-哪些方法会触发-react-重新渲染"}},[r._v("#")]),r._v(" （1）哪些方法会触发 react 重新渲染?")]),r._v(" "),t("ul",[t("li",[r._v("setState（）方法被调用（除了传入 null 的时候不会）")]),r._v(" "),t("li",[r._v("父组件重新渲染\n"),t("ul",[t("li",[r._v("只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render")])])])]),r._v(" "),t("h2",{attrs:{id:"_2-重新渲染-render-会做些什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-重新渲染-render-会做些什么"}},[r._v("#")]),r._v(" （2）重新渲染 render 会做些什么?")]),r._v(" "),t("p",[r._v("会对新旧 VNode 进行对比，也就是我们所说的 Diff 算法。\n对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面\n遍历差异对象，根据差异的类型，根据对应对规则更新 VNode")])])}),[],!1,null,null,null);t.default=s.exports}}]);
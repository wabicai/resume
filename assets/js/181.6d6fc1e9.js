(window.webpackJsonp=window.webpackJsonp||[]).push([[181],{477:function(t,e,v){"use strict";v.r(e);var _=v(10),i=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_1-git"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-git"}},[t._v("#")]),t._v(" 1.git")]),t._v(" "),e("ul",[e("li",[t._v("Workspace：工作区")]),t._v(" "),e("li",[t._v("Index / Stage：暂存区")]),t._v(" "),e("li",[t._v("Repository：仓库区（或本地仓库）")]),t._v(" "),e("li",[t._v("Remote：远程仓库")]),t._v(" "),e("li",[t._v("关键词：Git 是分布式版本控制系统，每个人的电脑就是一个完整的版本库")])]),t._v(" "),e("h1",{attrs:{id:"常见命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见命令"}},[t._v("#")]),t._v(" 常见命令")]),t._v(" "),e("ul",[e("li",[t._v("git clone：克隆远程仓库")]),t._v(" "),e("li",[t._v("git add：提交到暂存区")]),t._v(" "),e("li",[t._v("git diff：比较暂存区和工作区区别")]),t._v(" "),e("li",[t._v("git commit：暂存区=>本地仓库")]),t._v(" "),e("li",[t._v("git pull：拉取远程代码并合并")]),t._v(" "),e("li",[t._v("git push：推送代码到远程并合并")]),t._v(" "),e("li",[t._v("git stash：缓存暂存区和工作区的改动，保存在一个栈上面")]),t._v(" "),e("li",[t._v("git cherry-pick: 将其他分支的提交挑选到当前分支上")]),t._v(" "),e("li",[t._v("git switch: 切换分支到某个提交节点上，并且处于游离态")])]),t._v(" "),e("h2",{attrs:{id:"fork、clone、branch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fork、clone、branch"}},[t._v("#")]),t._v(" fork、clone、branch")]),t._v(" "),e("ul",[e("li",[t._v("fork：复制一份代码到远程仓库，远程仓库是你自己。可以通过 pull request 贡献给原仓库")]),t._v(" "),e("li",[t._v("clone：复制一份代码到你自己的仓库，远程仓库是 clone 的仓库。")]),t._v(" "),e("li",[t._v("branch：新开分支。")])]),t._v(" "),e("h2",{attrs:{id:"pull、fetch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pull、fetch"}},[t._v("#")]),t._v(" pull、fetch")]),t._v(" "),e("ul",[e("li",[t._v("pull：拉取远程仓库最新内容并直接合并。git pull = git fetch + git merge。")]),t._v(" "),e("li",[t._v("fetch：拉取远程仓库最新内容，用户检测之后决定是否合并到本机分支。")])]),t._v(" "),e("h2",{attrs:{id:"rebase、merge"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rebase、merge"}},[t._v("#")]),t._v(" rebase、merge")]),t._v(" "),e("ul",[e("li",[t._v("rebase："),e("code",[t._v("rebase")]),t._v("会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交。主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 "),e("code",[t._v("git merge")]),t._v("所需的不必要的合并提交\n"),e("ul",[e("li",[t._v("可以保留提交历史")])])]),t._v(" "),e("li",[t._v("merge：通过"),e("code",[t._v("merge")]),t._v("合并分支会新增一个"),e("code",[t._v("merge commit")]),t._v("，然后将两个分支的历史联系起来。其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂\n"),e("ul",[e("li",[t._v("会更改历史提交时间，可能会丢失上下文。")])])])]),t._v(" "),e("h2",{attrs:{id:"reset、revert"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reset、revert"}},[t._v("#")]),t._v(" reset、revert")]),t._v(" "),e("ul",[e("li",[t._v("reset：回退版本，"),e("strong",[t._v("遗弃")]),t._v("提交")]),t._v(" "),e("li",[t._v("revert：新增一次提交，抵消上一次提交导致的变化")])]),t._v(" "),e("blockquote",[e("p",[t._v("git revert 是用一次逆向的 commit“中和”之前的提交，因此日后合并老的 branch 时，之前提交合并的代码仍然存在，导致不能够重新合并")]),t._v(" "),e("p",[t._v("但是 git reset 是之间把某些 commit 在某个 branch 上删除，因而和老的 branch 再次 merge 时，这些被回滚的 commit 应该还会被引入")])]),t._v(" "),e("h3",{attrs:{id:"reset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reset"}},[t._v("#")]),t._v(" reset")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("常见用法")]),t._v(" "),e("ul",[e("li",[t._v("git reset --soft HEAD~1 （用于撤销 commit 到本地，还没 push 的提交）")])])]),t._v(" "),e("li",[e("p",[t._v("参数详解")])]),t._v(" "),e("li",[e("p",[t._v("--mixed：不删除工作空间改动代码，撤销 commit，并且撤销 git add . ，为默认参数,git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的。")])]),t._v(" "),e("li",[e("p",[t._v("--soft：不删除工作空间改动代码，撤销 commit，不撤销 git add .")])]),t._v(" "),e("li",[e("p",[t._v("--hard：删除工作空间改动代码，撤销 commit，撤销 git add . ，注意完成这个操作后，就恢复到了上一次的 commit 状态。")])]),t._v(" "),e("li",[e("p",[t._v("HEAD^的意思是上一个版本，也可以写成 HEAD~1，如果你进行了 2 次 commit，想都撤回，可以使用 HEAD~2")])])]),t._v(" "),e("ul",[e("li",[t._v("那么如何撤销已经推送到远程分支的代码呢？\n"),e("ol",[e("li",[t._v("git reset –-soft 或者 git reset –-hard (即本地先回滚)")]),t._v(" "),e("li",[t._v("git push origin 分支名 --force (强制把本地分支推送上去)")])])])])])}),[],!1,null,null,null);e.default=i.exports}}]);
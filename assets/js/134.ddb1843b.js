(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{427:function(v,_,t){"use strict";t.r(_);var a=t(10),e=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"_2-为什么-js-是边解释边执行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么-js-是边解释边执行"}},[v._v("#")]),v._v(" 2.为什么 js 是边解释边执行")]),v._v(" "),_("p",[v._v("转自：锐基同学的语雀")]),v._v(" "),_("h2",{attrs:{id:"面试官-怎么理解-js-边解释边执行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面试官-怎么理解-js-边解释边执行"}},[v._v("#")]),v._v(" 面试官：怎么理解 JS 边解释边执行？")]),v._v(" "),_("p",[v._v("阿里一面被面试官问了这个问题，问我为什么单线程还是可以答的上的，但问了我这个，一时哑口无言。这是我最常用的语言， "),_("code",[v._v("but")]),v._v(" 了解的还是不够深。")]),v._v(" "),_("p",[v._v("为了理解这个问题，我先去找了 "),_("code",[v._v("JavaScript")]),v._v(" 的解释：")]),v._v(" "),_("h2",{attrs:{id:"什么是-javascript"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-javascript"}},[v._v("#")]),v._v(" 什么是 JavaScript")]),v._v(" "),_("blockquote",[_("p",[_("a",{attrs:{href:"https://zh.wikipedia.org/wiki/JavaScript",target:"_blank",rel:"noopener noreferrer"}},[v._v("维基百科"),_("OutboundLink")],1),v._v(" ：JS 是一种高级的、解释型的编程语言。JavaScript 是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象程序设计，命令式编程，以及函数式编程。")]),v._v(" "),_("p",[v._v("在客户端，JS 在传统意义上被实现为一种解释语言，但最近它已经可以被即时编译（JIT）执行。")])]),v._v(" "),_("p",[v._v("这里涉及到了关键词“解释型”，那么问题就来了，什么是“解释型”的编程语言？")]),v._v(" "),_("h3",{attrs:{id:"什么解释型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么解释型"}},[v._v("#")]),v._v(" 什么解释型？")]),v._v(" "),_("p",[v._v("于是我接着在维基百科搜到：")]),v._v(" "),_("blockquote",[_("p",[v._v("解释型语言是一种编程语言的类型。这种类型的编程语言，将会代码一句一句直接运行，不需要像编译语言一样，经过编译器先行编译为机器代码，之后再运行。")]),v._v(" "),_("p",[v._v("这种变成语言需要利用解释器，在运行期，动态将代码逐句解释为机器码，或是已经预先编译为机器代码的子程序，之后再运行。")])]),v._v(" "),_("p",[v._v("我又纳闷了，解释器又是什么呢？那编译语言又和解释型语言有什么区别呢？")]),v._v(" "),_("p",[v._v("层层递进，我又去找了相关的资料。")]),v._v(" "),_("h3",{attrs:{id:"解释器是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解释器是什么"}},[v._v("#")]),v._v(" 解释器是什么？")]),v._v(" "),_("ul",[_("li",[v._v("解释器，是一种计算机程序，能够把解释型语言解释执行，就像一位“中间人”。")]),v._v(" "),_("li",[v._v("解释器边解释边执行，因此依赖于解释器的程序运行速度比较缓慢。")]),v._v(" "),_("li",[v._v("解释器的好处就是它不需要重新编译整个程序，从而减轻了每次程序更新后编译的负担。相对的编译器一次性将所有源代码编译成二进制文件，执行时则无需依赖编译器或其他额外的程序。")])]),v._v(" "),_("p",[v._v("解释器执行程序的方法有：")]),v._v(" "),_("ol",[_("li",[v._v("直接执行高级编程语言（如 "),_("code",[v._v("Shell")]),v._v(" 内建的编译器")]),v._v(" "),_("li",[v._v("转换高级变成语言到更有效率的字节码，并执行字节码")]),v._v(" "),_("li",[v._v("用解释器包含的编译器对高级语言进行编译，并指示中央处理器执行编译后的程序（如：JIT）")])]),v._v(" "),_("blockquote",[_("p",[v._v("JIT 即 just-in-time compilation，又译为即时编译、实时编译、动态翻译或运行时编译，是一种执行计算机代码的方法，它涉及在程序执行过程中（运行期）而不是在执行之前进行编译。通常，这包括源代码或更常见的字节码到机器码的转换，然后直接执行。")]),v._v(" "),_("p",[v._v("实现 "),_("code",[v._v("JIT")]),v._v(" 编译器的系统通常会不断地分析正在执行的代码，并确定代码的某些部分，在这些部分中，编译或重新编译所获得的加速将超过编译该代码的开销。")]),v._v(" "),_("p",[v._v("它的应用有如：正则表达式等")])]),v._v(" "),_("p",[v._v("使用解释器来运行程序会比直接运行编译过的机器代码来得慢，但是相对的这个解释的行为会比编译再运行来得快。因为解释器每次都必须去分析并翻译它运行到的程序行，而编译过的程序就只是直接执行。")]),v._v(" "),_("blockquote",[_("p",[v._v("Chrome 的 V8 引擎在运行之前将 JS 编译成了机器代码，而非字节码或是解释执行它，以此提升性能。")]),v._v(" "),_("ol",[_("li",[v._v("JS 的文本块或文件被解析成 一个 "),_("code",[v._v("AST")]),v._v(" 语法树")]),v._v(" "),_("li",[v._v("解释器解释执行，现在一般先从 "),_("code",[v._v("AST")]),v._v(" 输出一个字节码序列；也有直接从 "),_("code",[v._v("AST")]),v._v(" 上进行解释和计算的")]),v._v(" "),_("li",[v._v("对于热点代码，会有 "),_("code",[v._v("JIT")]),v._v(" 编译器从字节码出发，编译到内部的 "),_("code",[v._v("IR")]),v._v(" ，做一些优化，生成机器码。")])]),v._v(" "),_("ul",[_("li",[v._v("字节码：通常指的是已经经过编译，但与特定机器码无关，需要直译器转译后才能成为机器码的中间代码。如图")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/587100/1615709908939-61d93570-26d6-4067-9c85-384919c5d646.png",alt:"image"}})])]),v._v(" "),_("p",[v._v("总而言之，解释器就是一个可以把解释型语言（JS 等）解释执行的一种计算机程序。")]),v._v(" "),_("p",[v._v("解决了解释器的问题，那么解释执行和编译执行又有什么区别呢？根据上面的一些描述，想必你们心中也有一定的答案了，下面做一下总结，真不容易阿 😭")]),v._v(" "),_("h3",{attrs:{id:"解释执行和编译执行的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解释执行和编译执行的区别"}},[v._v("#")]),v._v(" 解释执行和编译执行的区别")]),v._v(" "),_("ul",[_("li",[v._v("编译执行：顾名思义要先编译再执行，这里需要一个编译器来讲代码全部编译成机器码，然后直接进行执行。")]),v._v(" "),_("li",[v._v("解释执行：它则需要一个解释器，它会将我们的一句句解释成机器代码来执行，可以认为解释一句，执行一句。也不会生成中间文件。")])]),v._v(" "),_("p",[v._v("对比可发现：")]),v._v(" "),_("ol",[_("li",[v._v("编译执行需要编译一次，就可以多次运行；而解释执行，每一次运行程序，都要经过解释器的解释过程。")])]),v._v(" "),_("p",[v._v("针对优缺点可以从以下几个方面分析：")]),v._v(" "),_("ol",[_("li",[v._v("从启动效率来看，解释执行不需要进行编译操作，而编译执行要经过编译。因此解释执行启动速度更快！")]),v._v(" "),_("li",[v._v("从运行效率来看，因为编译执行只需要编译一次，以后在运行就无需编译，而解释执行每次都要经过解释过程，所以编译执行的运行效率更高！")]),v._v(" "),_("li",[v._v("从内存使用方面来看，编译执行需要生成机器码文件，而解释执行时逐句解释执行，所以解释执行对内存占用更少。")]),v._v(" "),_("li",[v._v("从跨平台的角度来看，因为解释执行每次可以根据不同的平台进行解释，例如 "),_("code",[v._v("js")]),v._v(" 在 "),_("code",[v._v("linux")]),v._v(" 和 "),_("code",[v._v("windows")]),v._v(" 都可以运行，而 "),_("code",[v._v("C")]),v._v(" 在 "),_("code",[v._v("windows")]),v._v(" 下编译后的文件只能在 "),_("code",[v._v("windows")]),v._v(" 下才能执行。")])]),v._v(" "),_("p",[v._v("知道了上面这些概念之后，再来问：你是怎么理解边解释边执行的，是不是已经有头绪了？")])])}),[],!1,null,null,null);_.default=e.exports}}]);
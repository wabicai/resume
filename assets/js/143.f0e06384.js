(window.webpackJsonp=window.webpackJsonp||[]).push([[143],{423:function(t,e,r){"use strict";r.r(e);var a=r(14),n=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"_1-哪些方法会触发-react-重新渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-哪些方法会触发-react-重新渲染"}},[t._v("#")]),t._v(" （1）哪些方法会触发 react 重新渲染?")]),t._v(" "),e("ul",[e("li",[t._v("setState（）方法被调用（除了传入null的时候不会）")]),t._v(" "),e("li",[t._v("父组件重新渲染\n"),e("ul",[e("li",[t._v("只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render")])])])]),t._v(" "),e("h2",{attrs:{id:"_2-重新渲染-render-会做些什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-重新渲染-render-会做些什么"}},[t._v("#")]),t._v(" （2）重新渲染 render 会做些什么?")]),t._v(" "),e("p",[t._v("会对新旧 VNode 进行对比，也就是我们所说的Diff算法。\n对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面\n遍历差异对象，根据差异的类型，根据对应对规则更新VNode")])])}),[],!1,null,null,null);e.default=n.exports}}]);
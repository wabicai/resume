(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{453:function(t,s,a){"use strict";a.r(s);var r=a(10),i=Object(r.a)({},(function(){var t=this._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h1",{attrs:{id:"_3-进程与线程的通信方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-进程与线程的通信方式"}},[this._v("#")]),this._v(" 3.进程与线程的通信方式")]),this._v(" "),t("h2",{attrs:{id:"互斥锁-用于协调多线程访问同一共享资源的完整性-保证了同一时刻不存在多个线程同时访问一块共享资源的数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁-用于协调多线程访问同一共享资源的完整性-保证了同一时刻不存在多个线程同时访问一块共享资源的数据"}},[this._v("#")]),this._v(" 互斥锁：用于协调多线程访问同一共享资源的完整性；保证了同一时刻不存在多个线程同时访问一块共享资源的数据；")]),this._v(" "),t("p",[this._v("（1）当一个线程给这个资源上锁且还没有解锁前，其他线程是无法对该资源进行访问的\n（2）当一个线程对一块共享资源进行访问时上了锁，但是其他资源此时也想进行访问，则会挂起直到当前访问资源的线程解锁后，才会被唤醒再去访问\n（3）每次线程进行访问时上锁后，访问结束后一定记得解锁，否则会导致形成死锁，其他线程无法上锁，也无法访问")])])}),[],!1,null,null,null);s.default=i.exports}}]);
## 一、双等号==

### 1.是否有NaN

首先判断双等号两边是否有NaN，如果有的话，则一律返回false。

- NaN连自身都不相等：`NaN != NaN`

### 2.是否有boolean值

- 如果有的话则**将true转化为1，false转化为0。**

### 3.null和undefined

遇到null或者undefined，则不会进行类型转换，它们相互的比较都返回true。

- 除此之外，null和undefined跟其他元素比较都是false。

### 4.有一边是字符串

另外一边分四种情况：

1） 同样是字符串，则直接进行字符串值的比较

2） 是数字，则需要将字符串转化为数字，然后进行比较。如`"1" == 1`，`011==11`(前置0没了)

3） 有布尔类型，则要将布尔类型转化为0或者1，然后进行比较。

- 注意：除了 `1==true,0==false`， 其他都和布尔值不同。

4） **对象或者数组类型，则需要调用toString()或者valueOf()方法转化成简单类型，然后进行比较**

- 对象转化为简单类型时会优先调用valueOf方法，如果可以与简单值进行比较则会直接比较，此时不再调用toString方法。

- 如果调用valueOf方法后无法与简单值进行比较，则会再调用toString方法，最终得到比对的结果。

- 但是需要注意的一点是Date对象不满足上述的规则，Date对象的toString和valueOf方法都是重新定义过的，默认会调用toString方法。

如：

```js
[].toString() //得到"" ,""==0。所以[]==0==false=="" 。
//过程可以看作[].toString() => "" => "" == 0 => 0 == false

var a = {},a.toString() 
//"[object Object]"  所以{}和其他的基本类型都不相等，甚至{}!={}。

var a= new Date(2021,3,30)，var b= new Date(2021,3,30)
//结果： a != b

//其实 [] != [] ,{} !={}。因为引用类型都是栈存放的引用地址。看上去两个相同，但是他们的引用地址不同。
```

## 二、if（ ）里面的条件判断。

- 五种类型才会判定为false：`0、""、 NaN 、 undefined 、null`。`[ ]和{}都会判定为true`。
- 有趣的是，判定为false都是基本类型,而在非严格模式下，undefined == null，所以只算是四种。
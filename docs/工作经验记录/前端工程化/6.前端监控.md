# 前端可监控的类别

## 性能监控（监控页面性能）

* 不同用户，不同机型和不同系统下的首屏加载时间
* 白屏时间
* http 等请求的响应时间
* 静态资源整体下载时间
* 页面渲染时间
* 页面交互动画完成时间

## 用户数据监控

* PV/UV: PV(page view)：即页面浏览量或点击量；UV：指访问某个站点或点击某条新闻的不同 IP 地址的人数
* 用户在每一个页面的停留时间
* 用户通过什么入口来访问该网页
* 用户在相应的页面中触发的行为

## 异常监控

* Javascript 的异常监控
* 样式丢失的异常监控
# 埋点上报

## 手动埋点

* 调用埋点 SDK 的函数，在需要埋点的业务逻辑功能位置调用接口，上报埋点数据
* 手动埋点的缺陷就是，项目工程量大

## 可视化埋点

* 提供一个可视化交互的页面，输入为业务代码，在业务代码中自定义的增加埋点事件
* 可视化埋点的缺陷就是可以埋点的控件有限，不能手动定制。

## 无埋点

* 前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。
* 优点是前端只要一次加载埋点脚本
* 缺点是流量和采集的数据过于庞大，服务器性能压力山大。
# 监听方法

## 监听某个DOM节点

```JS
const exposeReportClass = new exposeReport({
    scrollDom: "", // 滚动容器，建议指定一个滚动容器，不传默认为window
    watchDom: ".bookitem", // 监听的dom,建议使用class类，标签也支持
    time: 1000 // 停留有效时长ms
});
// 提供两个上报方法
exposeReportClass.didReport(() => {
    // 手动上报
    //callback
})
exposeReportClass.scrollReport(() => {
    // 滚动动上报
    //callback
})
// 
```

# 为什么用gif埋点
* 防止跨域
一般而言，打点域名都不是当前域名，所以所有的接口请求都会构成跨域。
而跨域请求很容易出现由于配置不当被浏览器拦截并报错，这是不能接受的。
但图片的src属性并不会跨域，并且同样可以发起请求。（排除接口上报）

* 防止阻塞页面加载，影响用户体验

通常，创建资源节点后只有将对象注入到浏览器DOM树后，浏览器才会实际发送资源请求。反复操作DOM不仅会引发性能问题，而且载入js/css资源还会阻塞页面渲染，影响用户体验。

但是图片请求例外。构造图片打点不仅不用插入DOM，只要在js中new出Image对象就能发起请求，而且还没有阻塞问题，在没有js的浏览器环境中也能通过img标签正常打点，这是其他类型的资源请求所做不到的。（排除文件方式）

* 相比PNG/JPG，GIF的体积最小
最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节。

同样的响应，GIF可以比BMP节约41%的流量，比PNG节约35%的流量。
